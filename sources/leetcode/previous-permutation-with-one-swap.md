<!-- markdownlint-disable -->
<!-- customize-tags:贪心,数组 -->

# 1053. 交换一次的先前排列

> [题目链接](https://leetcode.cn/problems/previous-permutation-with-one-swap/)

给你一个正整数数组 `arr`（可能存在重复的元素），请你返回可在  **一次交换**（交换两数字 `arr[i]` 和 `arr[j]` 的位置）后得到的、按字典序排列小于 `arr` 的最大排列。

如果无法这么操作，就请返回原数组。

**示例 1：**

```
输入：arr = [3,2,1]
输出：[3,1,2]
解释：交换 2 和 1
```

**示例 2：**

```
输入：arr = [1,1,5]
输出：[1,1,5]
解释：已经是最小排列
```

**示例 3：**

```
输入：arr = [1,9,4,6,7]
输出：[1,7,4,6,9]
解释：交换 9 和 7
```

**提示：**

- `1 <= arr.length <= 104`
- `1 <= arr[i] <= 104`

<!-- markdownlint-restore -->
<!--------------------------------->
<!-- generate by new_leetcode.go -->

**代码实现：**
要求：

1. 只交换一次
2. 交换后的字典序小于原本的字典序
3. 交换后的字典序应该是所有方案中最大的一个

根据题目要求交换后需要比原本的字典序小，若原本是一个`非递减的序列`的话就没办法交换，交换出来的结果会大于或等于当前的字典序。  
交换后的字典序应该是所有方案中最大的一个，我们应该尽可能的去交换后面的数字。  
思路：从后向前枚举 `i` 使得 `arr[i] > arr[i + 1]`，此时交换 `arr[i]与arr[i + 1]` 就可以得到一个更小的字典序
同时此时满足 `[i, n)` 是一个递增的序列，需要找到一个 `j` 使得交换后的字典序最大，应该从后向前枚举 `j` 找到一个 `arr[j] < arr[i]` 的数当遇到重复的数时应当选前面数。

```go
func prevPermOpt1(arr []int) []int {
    n := len(arr)
    for i := n - 2; i > -1; i-- {
        if arr[i] > arr[i+1] {
            j := n - 1
            for arr[j] >= arr[i] || arr[j] == arr[j-1] {
                j--
            }
            t := arr[j]
            arr[j] = arr[i]
            arr[i] = t
            break
        }
    }
    return arr
}
```
