<!-- customize-category:JVM -->

# 深入理解 Java 虚拟机

- [深入理解 Java 虚拟机](#深入理解-java-虚拟机)
  - [运行时数据区域](#运行时数据区域)
    - [程序计数器](#程序计数器)
    - [Java 虚拟机栈](#java-虚拟机栈)
    - [本地方法栈](#本地方法栈)
    - [Java 堆](#java-堆)
    - [方法区](#方法区)
    - [运行时常量池](#运行时常量池)
    - [直接内存](#直接内存)
  - [对象](#对象)
    - [对象的创建](#对象的创建)
    - [对象的内存布局](#对象的内存布局)
    - [对象访问](#对象访问)
  - [GC](#gc)

## 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是 依赖用户线程的启动和结束而建立和销毁。

<img width=400 src="/assets/image/jvm-rumtime.png">

### 程序计数器

可以看作是当前线程所执行的字节码的行号指示器。它是程序控制流的指示器，分支、循环、跳转、异常处 理、线程恢复等基础功能都需要依赖这个计数器来完成。各条线程之间计数器互不影响，是一块**线程私有**的内存区域。

如果线程正在执行的是一个 Java 方法，这个记录器记录的是**正在执行的虚拟机字节码的指令地址**；如果正在执行的是一个本地方法，这个**记录器则为空(Undefined)**。此内存区域是唯一一个在《Java 虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。

### Java 虚拟机栈

与程序计数器一样也是线程私有的，生命周期与线程相同。

每个被方法执行时虚拟机都会同步创建一个**栈帧**用于保存局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。

在《Java 虚拟机规范》中，对这个内存区域规定了两类异常状况，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 **StackOverflowError** 异常，当栈**创建**或**扩展**(_HotSpot 虚拟机的栈容量是不可以动态扩展的_)时无法申请到足够的内存会抛出 **OutOfMemoryError** 异常。

### 本地方法栈

与虚拟机栈作用相似，是给 **Native** 方法使用的。

### Java 堆

Java 堆是虚拟机所管理的内存中最大的一块。它是线程共享的，在虚拟机启动时创建。

相关 JVM 参数：

- **-Xmx**: 堆的最大内存数，等同于-XX:MaxHeapSize
- **-Xms**: 堆的初始化初始化大小
- **-Xmn**: 堆中新生代初始及最大大小，如果需要进一步细化，初始化大小用-XX:NewSize，最大大小用-XX:MaxNewSize
- **-Xss**: 线程栈大小，等同于-XX:ThreadStackSize

### 方法区

方法区与堆一样，是一块共享的内存区域，他用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存。

HostSpot 虚拟机在 Java 8 之前采用永久代实现方法区，在 Java 8 之后改用元空间实现方法区。
永久代容易遇到**内存溢出**的问题。Oracle 在移植 JRockit（JRockit 中不存在永久代） 虚拟机时将永久代废弃，改用元空间实现方法区，**元空间采用的是本地内存**，大小限制取决于实际的实际内存。

根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 **OutOfMemoryError** 异常。

相关 JVM 参数：

- -XX:MetaspaceSize=20M 初始大小
- -XX:MaxMetaspaceSize=-1 最大值

### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池表，用于存放编译期生产的各种字面量与符合引用，这部分内容将在类加载后放到方法区的运行时常量池中。

运行时常量池具备动态性，Java 语言并不要求常量一定要在编译时产生。在运行期间也可以想常量池中存放数据例如 `String#intern()`

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出 OutOfMemoryError 异常。

### 直接内存

直接内存使用的是堆外内存，可以通过 DirectByteBuffer 对象操作。在一些场景中能显著提升性能，避免了 在 Java 堆和 Native 堆中来回复制数据。

## 对象

### 对象的创建

1. 当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程。

2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。

3. 内存分配完成之后，虚拟机必须将分配到的内存空间都初始化为零值。

4. 接下来，Java 虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用 O bject ::has hCode()方法时才 计算)、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据虚拟 机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行构造函数

### 对象的内存布局

在 HotSpot 虚拟机中对象的内存布局可以分为三个部分：`对象头、实例数据和对齐填充`
**对象头:**
**实例数据:**
实例数据就是在类中定义的字段，HotSpot 有者默认的分配顺序 `longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)`，在默认的分配策略中相同宽度的字体总是被分配到一起存放。

**对齐填充:**
HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是 任何对象的大小都必须是 `8`字节的整数倍。

### 对象访问

Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在《Java 虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义 这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实 现而定的，主流的访问方式主要有使用句柄和直接指针两种:
**直接指针:**
直接指针的好处是省了一次指针定位的开销。HotSpot 主要使用的是这种  
<img width=400 src="/assets/image/Snipaste_2023-04-05_18-40-50.png">

**句柄:**
Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息  
<img width=400 src="/assets/image/Snipaste_2023-04-05_18-43-38.png">

## GC
