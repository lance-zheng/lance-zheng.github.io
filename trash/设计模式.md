# 设计模式

todo: 每个模式写在一个文件中

- [设计模式](#设计模式)
  - [创建型设计模式](#创建型设计模式)
    - [单例模式 (Singleton Pattern)](#单例模式-singleton-pattern)
    - [工厂模式 (Factory Pattern)](#工厂模式-factory-pattern)
      - [简单工厂模式 (Simple Factory Pattern)](#简单工厂模式-simple-factory-pattern)
      - [工厂方法模式（Factory Method Pattern）](#工厂方法模式factory-method-pattern)
      - [抽象工厂模式 (Abstract Factory Pattern)](#抽象工厂模式-abstract-factory-pattern)
    - [建造者模式 (Builder Pattern)](#建造者模式-builder-pattern)
  - [结构型设计模式](#结构型设计模式)
    - [适配器模式 (Adapter Pattern)](#适配器模式-adapter-pattern)
    - [装饰器模式 (Decorator Pattern)](#装饰器模式-decorator-pattern)
    - [外观模式 (Facade Pattern)](#外观模式-facade-pattern)
  - [行为型设计模式](#行为型设计模式)
    - [观察者模式 (Observer Pattern)](#观察者模式-observer-pattern)
    - [策略模式 (Strategy Pattern)](#策略模式-strategy-pattern)
    - [模板方法模式 (Template Method Pattern)](#模板方法模式-template-method-pattern)
    - [迭代器模式 (Iterator Pattern)](#迭代器模式-iterator-pattern)
    - [责任链模式 (Chain of Responsibility Pattern)](#责任链模式-chain-of-responsibility-pattern)

## 创建型设计模式

### 单例模式 (Singleton Pattern)

### 工厂模式 (Factory Pattern)

工厂模式是一种创建型的设计模式，其目的是为了提供一组通用的接口来创建对象，**调用者不需要关心对象创建逻辑**。通过工厂模式，**可以将对象的创建与使用分离**，从而代码更加灵活，可拓展和易于维护。

#### 简单工厂模式 (Simple Factory Pattern)

简单工厂模式是有一个工厂类根据传入的参来决定创建哪种产品。客户端通过调用工厂方类的静态方法来创建对象

```java
// Shape 接口
public interface Shape {
    void draw();
}

// Circle 类
public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

// Rectangle 类
public class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
}

// ShapeFactory 工厂类
public class ShapeFactory {
    public static Shape createShape(String shapeType) {
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        }
        return null;
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Shape circle = ShapeFactory.createShape("CIRCLE");
        Shape rectangle = ShapeFactory.createShape("RECTANGLE");
        circle.draw(); // 输出：Drawing Circle
        rectangle.draw(); // 输出：Drawing Rectangle
    }
}
```

#### 工厂方法模式（Factory Method Pattern）

工厂方法模式`定义一个用于创建对象的接口`，让子类去决定实例化那个类，`将对象的创建延迟到子类中进行`。

```java
// Logger 接口
public interface Logger {
    void log(String message);
}

// ConsoleLogger 类
public class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("Console Logger: " + message);
    }
}

// FileLogger 类
public class FileLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("File Logger: " + message);
    }
}

// LoggerFactory 接口
public interface LoggerFactory {
    Logger createLogger();
}

// ConsoleLoggerFactory 类
public class ConsoleLoggerFactory implements LoggerFactory {
    @Override
    public Logger createLogger() {
        return new ConsoleLogger();
    }
}

// FileLoggerFactory 类
public class FileLoggerFactory implements LoggerFactory {
    @Override
    public Logger createLogger() {
        return new FileLogger();
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        LoggerFactory factory1 = new ConsoleLoggerFactory();
        Logger logger1 = factory1.createLogger();
        logger1.log("Hello, ConsoleLogger"); // 输出：Console Logger: Hello, ConsoleLogger

        LoggerFactory factory2 = new FileLoggerFactory();
        Logger logger2 = factory2.createLogger();
        logger2.log("Hello, FileLogger"); // 输出：File Logger: Hello, FileLogger
    }
}
```

#### 抽象工厂模式 (Abstract Factory Pattern)

抽象工厂模式提供一个一个创建`一系列相关或相互依赖对象的接口`，而无需指定它们的具体类。通过抽象工厂模式，可以将一组相关的产品组合层一个产品族，以便在不同的环境中使用。

抽象工厂和工厂方法模式不同的是，工厂方法模式关注的是单个产品，而抽象工厂模式关注的是多个产品。

在抽象工厂模式中，有多个抽象产品类，每个抽象产品类可以有多个具体实现类，而每个具体实现类都属于某个产品族。抽象工厂类中定义了用于创建不同产品族的抽象方法，每个具体工厂类实现了抽象工厂中的方法，用于创建不同产品族的具体产品。

```java
// Button 接口
public interface Button {
    void paint();
}

// WinButton 类
public class WinButton implements Button {
    @Override
    public void paint() {
        System.out.println("Painting a Windows button");
    }
}

// MacButton 类
public class MacButton implements Button {
    @Override
    public void paint() {
        System.out.println("Painting a Mac button");
    }
}

// Checkbox 接口
public interface Checkbox {
    void paint();
}

// WinCheckbox 类
public class WinCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Painting a Windows checkbox");
    }
}

// MacCheckbox 类
public class MacCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Painting a Mac checkbox");
    }
}

// GUIFactory 接口
public interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// WinFactory 类
public class WinFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WinButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new WinCheckbox();
    }
}

// MacFactory 类
public class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        GUIFactory factory1 = new WinFactory();
        Button button1 = factory1.createButton();
        Checkbox checkbox1 = factory1.createCheckbox();
        button1.paint(); // 输出：Painting a Windows button
        checkbox1.paint(); // 输出：Painting a Windows checkbox

        GUIFactory factory2 = new MacFactory();
        Button button2 = factory2.createButton();
        Checkbox checkbox2 = factory2.createCheckbox();
        button2.paint(); // 输出：Painting a Mac button
        checkbox2.paint(); // 输出：Painting a Mac checkbox
    }
}
```

### 建造者模式 (Builder Pattern)

## 结构型设计模式

### 适配器模式 (Adapter Pattern)

它可以让原本接口不兼容的类能够协同工作。适配器模式通过创建一个新的适配器类，将一个或多个不兼容的类的接口转换为客户端所期望的接口。
框架中的应用：
**org.springframework.web.servlet.HandlerAdapter**  
在 SpringMVC 定义控制器的方式有很多种，例如有实现 Controller 接口，也基于方法的。每种控制器的执行方式都不一样，所以需要一个是适配器来做适配

### 装饰器模式 (Decorator Pattern)

它允许你动态地向一个对象添加新的行为，同时又不改变该对象的结构。在这种模式中，创建一个装饰器类，该类实现了要装饰的接口，并且持有一个对被装饰对象的引用。装饰器类通过调用被装饰对象的方法来实现原有行为，然后再添加新的行为或者修改原有行为。

例如 java io 包中通过 BufferedInputStream 可以将 FileInputStream 增强为一个带有缓冲区的流

```java
FileInputStream fileInputStream = new FileInputStream("");
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```

装饰器模式可以在不改变原有对象结构的情况下，动态地添加新的行为，从而提高系统的灵活性和可扩展性。

### 外观模式 (Facade Pattern)

## 行为型设计模式

### 观察者模式 (Observer Pattern)

### 策略模式 (Strategy Pattern)

### 模板方法模式 (Template Method Pattern)

它定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现。在这种模式中，算法的具体实现被延迟到子类中，同时算法的整体结构不会改变。

框架中的应用：
**RestTemplate** 里面的 doExecute 函数

### 迭代器模式 (Iterator Pattern)

### 责任链模式 (Chain of Responsibility Pattern)

Java web 中的 filter

责任链模式可以有效地降低系统的耦合度，使得每个处理者都可以专注于自身的业务逻辑，从而提高系统的可扩展性和可维护性。
